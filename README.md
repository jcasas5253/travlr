Architecture

There were notable differences as well as parallels across the frontend development methodologies. Even though they all used different amounts of static HTML and CSS, Single-Page Applications (SPAs) and Express development were more similar to each other than they were to their static HTML or JavaScript-only equivalents. Though they did it in very different ways, Express and SPAs both dynamically created pages depending on the necessary content. Express depended on a large number of pages with repetitive text and similar components, such as lists, headers, and footers. Loops filled in the gaps on the page, Handlebars gave the syntax, and the database supplied the data. This made it easier for pages to load and made editing common parts easier. On a strictly static HTML website, for example, changing the header or navbar would require changing those components in each related HTML file. By comparison, Express ensured uniform application across all sites by just requiring altering the header Handlebars template. Express, nevertheless, continued to function inside the confines of many pages. This is where the single-page loading feature of SPAs set them apart. Upon the initial page load, all images, CSS, and HTML are downloaded. Then, using a router like to Express, portions of the page are rebuilt while the user navigates. However, fragments are loaded using database API calls rather than new pages. As a consequence, server load is decreased and navigation is quicker and more fluid. Essentially, the degree of page loading granularity determines the major distinction. SPAs function at the fragment level, whereas Express functions at the page level. SPAs benefit greatly from this distinction in terms of performance and maintainability, especially for big and complicated applications.

We chose to use MongoDB for a number of compelling reasons. First off, we were able to design bespoke schemas with selective indexing and set flexible parameters thanks to MongoDB's schema flexibility. But since MongoDB runs on JavaScript, the main reason for selecting it over a conventional SQL database was its smooth interaction with the MEAN architecture. This made it possible for us to streamline development and maintenance by keeping the JavaScript codebase uniform throughout the frontend, backend, and database. MongoDB's ease of setup, ease of hosting, and seamless interaction with the MEAN stack added to its allure. For example, in our application, a straightforward db.trips file was used to get all trips.Unlike the longer SQL counterpart, SELECT * FROM trips, the find({}) call is shorter. In a similar vein, retrieving a specific trip using a code necessitates db.trips.A more direct replacement for SELECT * FROM trips WHERE code IS $code is find({"code": "$code"}). The code readability and maintainability were enhanced by MongoDB's concise and consistent syntax, which complemented the entire structure of the MEAN stack well. Overall, MongoDB was the best option for our application's database requirements due to its adaptability, JavaScript compatibility, and benefits with integration.

Functionality

Structured data is represented in a key-value pair format using JSON, or JavaScript Object Notation, a data exchange standard. In contrast to programming languages, JSON does not allow code to run. Rather, it acts as a way to transfer and store data in a format that can be understood by both computers and humans. Given that the frontend depends on JavaScript objects, JSON is a perfect choice for data transfer between the frontend and backend. Trip data is sent to the frontend after being serialized into JSON format in the example given. After that, the frontend deserializes the JSON data into JavaScript objects so that it may be easily edited and shown. To render data for the end user and fill HTML fields, for example, utilize the trip.name, trip.image, and trip.description properties. JSON's continued importance is further supported by the backend's usage of MongoDB. MongoDB uses the BSON format, a binary version of JSON, for storing data. The smooth data interchange between the frontend and backend is made possible by the close link between JSON and BSON. For example, to add, update, or remove records, the frontend can use MongoDB calls to transmit JSON data to the backend. In a similar vein, the backend can reply to read requests from the client using JSON. JSON essentially acts as a bridge language, allowing data to be seamlessly transferred between the frontend and backend. Its machine-parsability, readability, and simplicity make it the perfect option for data transport in contemporary online applications.

The travels page was first created with static HTML. The page was refactored to use Handlebars templates in combination with static JSON data in an attempt to increase the maintainability and effectiveness of the user interface development process. This reduced the codebase from about 5–6 lines of HTML per trip to a single, reusable template by doing away with the requirement to maintain a distinct HTML fragment for each trip component. The development process was further streamlined by the use of Handlebars' {{#each}} and {{/each}} tags, which allowed trip data to be rendered dynamically within the template. By using Handlebars templates, reusable UI components were made easier to create and the risk of mistake associated with copying and pasting HTML code was reduced. Developers may cut down on the amount of boilerplate code needed to create user interfaces by encapsulating common UI elements into templates. This lowers the possibility of mistakes while also making the codebase easier to understand and manage. The journeys page was then further redesigned to use a database as the data source. This greatly streamlined the development and maintenance process by doing away with the requirement for manual maintenance of static JSON data. Additionally, centralized create, read, update, and delete (CRUD) processes were made possible by the introduction of database-driven data retrieval. This lessened the possibility of user mistake while also making the construction of data-driven features simpler.

Testing

Based on my experience working on this project, the main testing techniques used were console log messages, status codes, and running tests using Postman or the real website with fictitious data. While console log reports helped pinpoint precise places in the code where errors occurred, status codes offered hints as to where the problems could be. For example, a number of console log messages were used to identify a flaw in the setPassword function during the development of the login function. It was discovered that the password okay log was not being shown by include a log message at every stage of the login procedure. This made it possible to identify and fix the issue. There are four types of API methods: GET, POST, PUT, and DELETE. HTML operations make these techniques easier to use. The database is called to read from using the GET method, to create entries using the POST method, to update entries using the PUT method, and to delete entries using the DELETE method. A full stack developer must prioritize the security of endpoints. Sensitive endpoints (POST and PUT) in our application were encapsulated in a check to ensure user login credentials. This did not stop unregistered users from registering and sending PUT or POST queries afterward, either. It will be necessary to fix this security flaw in later iterations of the website. Modern online projects need to prioritize security, which means that security must be carefully examined at every stage of development.

Reflection

My career aspirations of being a versatile and employable software engineer have been greatly aided by CS-465 Full Stack Development. My grasp of the entire stack development lifecycle, from front-end programming and UX design to back-end programming and database administration, has improved greatly as a result of this training. In addition, I have developed important skills in communication, cooperation, and project management. To succeed in any profession involving software engineering, these abilities are necessary. I am now confident in my abilities to design, create, and deploy full-stack web apps after finishing CS-465 Full Stack Development. Additionally, I have faith in my capacity to pick up new skills and adjust to shifting market trends. I think that the information and abilities I've acquired in this course will help me stand out as a candidate in my line of work. I can't wait to use my abilities on actual projects and add to the creation of superior software. I appreciate the chance to discuss how CS-465 Full Stack Development has aided me in achieving my career objectives.
